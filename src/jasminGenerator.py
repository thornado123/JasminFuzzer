"""

    The Jasmin program generator is a deterministic Jasmin source program generator
    that take a seed token and generates a program with offset in this token.


    Methods:

        __init__:

            - set the current seed value

        getProgram:

            - given a seed value return a valid Jasmin program


    Jasmin BNF:

    TYPES:

    <ptype>     ::= T_BOOL | T_INT | <utype> | <utype><brackets <pexpr>>
    <utype>     ::= T_U8 | T_U16 | T_U32 | T_U64 | T_U128 | T_U256


    EXPRESSIONS:

    <pexpr>     ::= <var> | <var><brackets<pexpr>> | TRUE | FALSE | INT | [<parens<ptype>>]<brackets(<var>+<pexpr>)>
                | <peop1><pexpr> | <pexpr><peop2><pexpr> | <parens<pexpr>> | <var><parens_tuple<pexpr>>
                | <prim><parens_tuple<pexpr>>

    <ident>     ::= NID
    <var>       ::= <ident>
    <prim>      ::= #<ident>

    <peop1>     ::= ! | -
    <peop2>     ::= + | - | * | && | PIPEPIPE | & | PIPE | ^ | << | >> | >>s | == | != | < | <= | > | >= | <s | <=s | >s
                | >=s

    INSTRUCTIONS:

    <pinstr>    ::= ARRAYINIT ⟨parens⟨var⟩⟩ ;
                | ⟨tuple1⟨plvalue⟩⟩ ⟨peqop⟩ ⟨pexpr⟩ [IF ⟨pexpr⟩] ; | ⟨var⟩ ⟨parens_tuple⟨pexpr⟩⟩ ;
                | IF ⟨pexpr⟩ ⟨pblock⟩
                | IF ⟨pexpr⟩ ⟨pblock⟩ ELSE ⟨pblock⟩
                | FOR ⟨var⟩ = ⟨pexpr⟩ TO ⟨pexpr⟩ ⟨pblock⟩
                | FOR ⟨var⟩ = ⟨pexpr⟩ DOWNTO ⟨pexpr⟩ ⟨pblock⟩ | WHILE [⟨pblock⟩] ⟨parens⟨pexpr⟩⟩ [⟨pblock⟩]

    <pblock>    ::= ⟨braces⟨pinstr⟩*⟩

    <peqop>     ::= =
                | += | -= | *=
                | >>= |>>s= |<<=
                | &= |^= | PIPEEQ

    <plvalue>   ::= UNDERSCORE | <var> | <var> <brackets<pexpr>> | [<parens<ptype>>]<brackets(<var> + <pexpr>)>

    FUNCTIONS:

    <pfunbody>  ::= LBRACE (⟨pvardecl⟩ ;)∗ ⟨pinstr⟩∗ [RETURN ⟨tuple⟨var⟩⟩ ;] RBRACE

    <storage>   ::= REG | STACK | INLINE

    <stor_type> ::= <storage><ptype>
    <pvardecl>  ::= <stor_type><var>


    GLOBAL DECLARATIONS:

    <module>    ::= <top> * EOF | error
    <top>       ::= <pfundef> | <pparam> | <pglobal>
    <call_conv> ::= EXPORT | INLINE //Inline is default
    <pfundef>   ::= [<call_conv>]FN <ident> <parens_tuple(<stor_type><var>)>[-><tuple<stor_type>>]<pfunbody>
    <pparam>    ::= PARAM <ptype><ident> = <pexpr>;
    <pglobal>   ::= <ident> = <pexpr>;

"""

import numpy as np
import jasminDistribution as JD
from jasminNonterminalAndTokens import Nonterminals as JN
from jasminScopes import Scopes as JS
from datetime import datetime



class JasminGenerator:

    def __init__(self, program_seed):

        self.seed               = program_seed
        self.action_global      = JD.GlobalDeclarations(self.seed)
        self.action_types       = JD.Types(self.seed)
        self.action_functions   = JD.Functions(self.seed)
        self.action_expressions = JD.Expressions(self.seed)
        self.action_instructions= JD.Instructions(self.seed)

        self.variables = {

            JS.Variables    : [],
            JS.Function_name: [],
            JS.Decl         : []

        }

    def get_program(self):

        program = "// Program seed: " + str(self.seed) + "\n" \
                + "// Generated by JasminFuzzer on " + str(datetime.now()) + " \n\n"

        amount_of_global_decls = 1  # self.action_prop(self.seed, "global")

        for _ in range(amount_of_global_decls):

            program += self.global_declarations()

        return program

    def get_variable(self, scope):

        print("scope: ", scope)

        if scope == JS.Variables:

            index = np.random.choice(self.variables[JS.Variables], 1, replace=False)
            return index[0]

        if scope == JS.Decl:

            new_var = "v"

            if len(self.variables[JS.Variables]) == 0:

                self.variables[JS.Variables] = [new_var + "0"]
                return new_var + "0"

            else:

                self.variables[JS.Variables].append(new_var + str(len(self.variables[JS.Variables])))
                return new_var + str(len(self.variables[JS.Variables]))

        if scope == JS.Function_name:

            if self.variables[JS.Function_name] == 0:

                new_func = "f0"
                self.variables[JS.Function_name] = [new_func]
                return new_func

            else:

                new_func = "f" + str(len(self.variables[JS.Function_name]))
                self.variables[JS.Function_name].append(new_func)

                return new_func

    """
    
        Global decl. 
        
        Is at depth 0
        
    """

    def global_declarations(self, action=None):

        if action is None:

            action = self.action_global.get_action()

        if action == JN.Module:

            action = self.action_global.get_action(JN.Module)

            if action == JN.Top:

                return self.global_declarations(JN.Top)+" * EOF"

            else:

                return "error"

        if action == JN.Top:

            action = self.action_global.get_action(JN.Top)

            if action == JN.Pfundef:

                return self.global_declarations(JN.Pfundef)

            if action == JN.Param:

                return self.global_declarations(JN.Param)

            if action == JN.Pglobal:

                return self.global_declarations(JN.Pglobal)

        if action == JN.Call_conv:

            action = self.action_global.get_action(JN.Call_conv)

            if action == "export":

                return "export"

            else:

                return "inline"  # inline is default

        if action == JN.Pfundef:

            return self.global_declarations(action=JN.Call_conv) + " fn " \
                    + self.expressions(action=JN.Ident, scope=JS.Function_name, r_depth=0) + "(" \
                    + self.functions(action=JN.Stor_type, r_depth=0) + " "\
                    + self.expressions(action="var", scope=JS.Decl, r_depth=0) + ") -> " \
                    + self.functions(action=JN.Stor_type, r_depth=0) \
                    + self.functions(action=JN.Pfunbody, r_depth=0)

        if action == JN.Param:

            return JN.Param + self.types(action=JN.Ptype) + self.expressions(action=JN.Ident, r_depth=0)\
                   + " = " + self.expressions(action=JN.Pexpr, r_depth=0)

        if action == JN.Pglobal:

            return self.expressions(action=JN.Ident, r_depth=0) + " = " + self.expressions(action=JN.Pexpr, r_depth=0)

    """
    
        EXPRESSIONS
        
        Are at a variable level as they can be recursively defined
    
    """

    def expressions(self, action=None, scope=None, r_depth=0):

        if action is None:

            action = self.action_expressions.get_action(r_depth=r_depth)

        if action == JN.Pexpr:

            action = self.action_expressions.get_action(sub=JN.Pexpr, r_depth=r_depth)

            if action == "true":

                return "true"

            if action == "false":

                return "false"

            if action == "int":

                return "int"

            if action == "var":

                return self.expressions(action="var", scope=scope, r_depth=r_depth)

            if action == "array":

                return self.expressions(action="var", scope=scope, r_depth=r_depth) + "[" \
                       + self.expressions(action=JN.Pexpr, scope=scope, r_depth=r_depth) + "]"

            if action == "negvar":

                return self.expressions(action=JN.Peop1, r_depth=r_depth)\
                       + self.expressions(action=JN.Pexpr, scope=scope, r_depth=r_depth)

            if action == "exp":

                return self.expressions(action=JN.Pexpr, scope=scope, r_depth=r_depth) \
                       + self.expressions(action=JN.Peop2, r_depth=r_depth)\
                       + self.expressions(action=JN.Pexpr, scope=scope, r_depth=r_depth)

        if action == JN.Peop1:

            return self.action_expressions.get_action(sub=JN.Peop1, r_depth=r_depth)

        if action == JN.Peop2:

            return self.action_expressions.get_action(sub=JN.Peop2, r_depth=r_depth)

        if action == "var" or action == JN.Ident:

            return self.get_variable(scope)

    """

        INSTRUCTIONS

    """

    def instructions(self, action=None, r_depth=0):

        print("Instruction  action ", action)

        if action is None:

            action = self.action_instructions.get_action(r_depth=r_depth)

        if action == JN.Pinstr:

            action = self.action_instructions.get_action(sub=JN.Pinstr, r_depth=r_depth)

            if action == "arrayinit":

                return "arrayinit"  #TODO what is arrayinit?

            if action == "if":

                return "if " + self.expressions(action=JN.Pexpr, r_depth=r_depth) \
                       + self.instructions(action=JN.Pblock, r_depth=r_depth)

            if action == "ifelse":

                return "if " + self.expressions(action=JN.Pexpr, r_depth=r_depth)\
                       + self.instructions(action=JN.Pblock, r_depth=r_depth) \
                       + " else " + self.instructions(action=JN.Pblock, r_depth=r_depth)

            if action == "forto":

                return "for " + self.expressions(action="var", r_depth=r_depth) + " = "\
                       + self.expressions(action=JN.Pexpr, r_depth=r_depth) + " to " \
                       + self.expressions(action=JN.Pexpr, r_depth=r_depth) \
                       + self.instructions(action=JN.Pblock, r_depth=r_depth)

            if action == "fordown":

                return "for " + self.expressions(action="var", r_depth=r_depth) + " = " \
                       + self.expressions(action=JN.Pexpr, r_depth=r_depth) + " downto " \
                       + self.expressions(action=JN.Pexpr, r_depth=r_depth)\
                       + self.instructions(action=JN.Pblock, r_depth=r_depth)

            if action == "while":

                return "while " + self.instructions(action=JN.Pblock, r_depth=r_depth) + "{\n" \
                       + self.expressions(action=JN.Pexpr, scope=JS.Variables, r_depth=r_depth) + "\n}" \
                       + self.instructions(action=JN.Pblock, r_depth=r_depth)

        if action == JN.Peqop:

            return "(<var><peqop><var>)"  #TODO make such that it return <var><peqop><var>

        if action == JN.Pblock:

            return "PBLOCK"  #self.instructions(action=JN.Peqop)

        if action == JN.Plvalue:

            action = self.action_instructions.get_action(sub=JN.Plvalue, r_depth=r_depth)

            if action == "_":

                return "_"

            if action == "var":

                return self.expressions(action="var", r_depth=r_depth)

            if action == "array":

                return self.expressions(action="var", r_depth=r_depth) + "[" \
                       + self.expressions(action=JN.Pexpr, r_depth=r_depth) + "]"

    """
    
        FUNCTIONS
    
    """

    def functions(self, action=None, r_depth=0):

        if action is None:

            action = self.action_functions.get_action()

        if action == JN.Pfunbody:

            return "{\n" + self.functions(action=JN.Pvardecl, r_depth=r_depth)\
                   + self.instructions(JN.Pinstr, r_depth=r_depth) + "\nreturn "\
                   + self.functions(action="return", r_depth=r_depth) + ";\n}"

        if action == JN.Storage:

            return self.action_functions.get_action(sub=JN.Storage, r_depth=r_depth)

        if action == JN.Stor_type:

            return self.functions(action=JN.Storage, r_depth=r_depth) + " " \
                   + self.types(action=JN.Ptype, r_depth=r_depth)

        if action == JN.Pvardecl:

            return self.functions(action=JN.Stor_type, r_depth=r_depth) + " "\
                   + self.expressions(action="var", scope=JS.Decl, r_depth=r_depth) + ";\n"

        if action == "return":

            return "return_variable"  # can be a tuple

    """
    
        TYPES
    
    """

    def types(self, action=None, r_depth=0):

        if action is None:

            action = self.action_types.get_action()

        if action == JN.Ptype:

            action = self.action_types.get_action(sub=JN.Ptype, r_depth=r_depth)

            if action == "bool":

                return "bool"

            if action == "int":

                return "int"

            if action == JN.Utype:

                return self.types(action=JN.Utype, r_depth=r_depth)

            if action == "array":

                return self.types(action=JN.Utype, r_depth=r_depth) + "["\
                       + self.expressions(action=JN.Pexpr, r_depth=r_depth) + "]"

        if action == JN.Utype:

            return self.action_types.get_action(sub=JN.Utype, r_depth=r_depth)







