"""

    The Jasmin program generator is a deterministic Jasmin source program generator
    that take a seed token and generates a program with offset in this token.


    Methods:

        __init__:

            - set the current seed value

        getProgram:

            - given a seed value return a valid Jasmin program


    Jasmin BNF:

    TYPES:

    <ptype>     ::= T_BOOL | T_INT | <utype> | <utype><brackets <pexpr>>
    <utype>     ::= T_U8 | T_U16 | T_U32 | T_U64 | T_U128 | T_U256


    EXPRESSIONS:

    <pexpr>     ::= <var> | <var><brackets<pexpr>> | TRUE | FALSE | INT | [<parens<ptype>>]<brackets(<var>+<pexpr>)>
                | <peop1><pexpr> | <pexpr><peop2><pexpr> | <parens<pexpr>> | <var><parens_tuple<pexpr>>
                | <prim><parens_tuple<pexpr>>

    <ident>     ::= NID
    <var>       ::= <ident>
    <prim>      ::= #<ident>

    <peop1>     ::= ! | -
    <peop2>     ::= + | - | * | && | PIPEPIPE | & | PIPE | ^ | << | >> | >>s | == | != | < | <= | > | >= | <s | <=s | >s
                | >=s

    INSTRUCTIONS:

    <pinstr>    ::= ARRAYINIT ⟨parens⟨var⟩⟩ ;
                | ⟨tuple1⟨plvalue⟩⟩ ⟨peqop⟩ ⟨pexpr⟩ [IF ⟨pexpr⟩] ; | ⟨var⟩ ⟨parens_tuple⟨pexpr⟩⟩ ;
                | IF ⟨pexpr⟩ ⟨pblock⟩
                | IF ⟨pexpr⟩ ⟨pblock⟩ ELSE ⟨pblock⟩
                | FOR ⟨var⟩ = ⟨pexpr⟩ TO ⟨pexpr⟩ ⟨pblock⟩
                | FOR ⟨var⟩ = ⟨pexpr⟩ DOWNTO ⟨pexpr⟩ ⟨pblock⟩ | WHILE [⟨pblock⟩] ⟨parens⟨pexpr⟩⟩ [⟨pblock⟩]

    <pblock>    ::= ⟨braces⟨pinstr⟩*⟩

    <peqop>     ::= =
                | += | -= | *=
                | >>= |>>s= |<<=
                | &= |^= | PIPEEQ

    <plvalue>   ::= UNDERSCORE | <var> | <var> <brackets<pexpr>> | [<parens<ptype>>]<brackets(<var> + <pexpr>)>

    FUNCTIONS:

    <pfunbody>  ::= LBRACE (⟨pvardecl⟩ ;)∗ ⟨pinstr⟩∗ [RETURN ⟨tuple⟨var⟩⟩ ;] RBRACE

    <storage>   ::= REG | STACK | INLINE

    <stor_type> ::= <storage><ptype>
    <pvardecl>  ::= <stor_type><var>


    GLOBAL DECLARATIONS:

    <module>    ::= <top> * EOF | error
    <top>       ::= <pfundef> | <pparam> | <pglobal>
    <call_conv> ::= EXPORT | INLINE //Inline is default
    <pfundef>   ::= [<call_conv>]FN <ident> <parens_tuple(<stor_type><var>)>[-><tuple<stor_type>>]<pfunbody>
    <pparam>    ::= PARAM <ptype><ident> = <pexpr>;
    <pglobal>   ::= <ident> = <pexpr>;

"""

import jasminDistribution as JD
from datetime import datetime


class JasminGenerator:

    def __init__(self, program_seed):

        self.seed               = program_seed
        self.action_global      = JD.GlobalDeclarations(self.seed)
        self.action_types       = JD.Types(self.seed)
        self.action_functions   = JD.Functions(self.seed)
        self.action_expressions = JD.Expressions(self.seed)
        self.action_instructions = JD.Instructions(self.seed)

    def get_program(self):

        program = "// Program seed: " + str(self.seed) + "\n" \
                + "// Generated by JasminFuzzer on " + str(datetime.now()) + " \n\n"

        amount_of_global_decls = 1  # self.action_prop(self.seed, "global")

        for _ in range(amount_of_global_decls):

            program += self.global_declarations()

        return program

    def global_declarations(self, action=None):

        if action is None:

            action = self.action_global.get_action()

        if action == "module":

            action = self.action_global.get_action("module")

            if action == "top":

                return self.global_declarations("top")+" * EOF"

            else:

                return "error"

        if action == "top":

            action = self.action_global.get_action("top")

            if action == "pfundef":

                return self.global_declarations("pfundef")

            if action == "pparam":

                return self.global_declarations("pparam")

            if action == "pglobal":

                return self.global_declarations("pglobal")

        if action == "call_conv":

            action = self.action_global.get_action("call_conv")

            if action == "export":

                return "export"

            else:

                return "inline"  # inline is default

        if action == "pfundef":

            return self.global_declarations(action="call_conv") + " fn " + self.expressions(action="ident") + \
                    "(" + self.functions(action="stor_type") \
                    + self.expressions(action="var") + ") -> (" \
                    + self.functions(action="stor_type") + ")" \
                    + self.functions(action="pfunbody")

        if action == "pparam":

            return "param" + self.types(action="ptype") + self.expressions(action="ident") + " = " + self.expressions(action="pexpr")

        if action == "pglobal":

            return self.expressions(action="ident") + " = " + self.expressions(action="pexpr")

    """
    
        EXPRESSIONS
    
    """

    def expressions(self, action=None):

        if action is None:

            action = self.action_expressions.get_action()

        if action == "pexpr":

            action = self.action_expressions.get_action(sub="pexpr")

            if action == "true":

                return "true"

            if action == "false":

                return "false"

            if action == "int":

                return "int"

            if action == "var":

                return self.expressions(action="var")

            if action == "array":

                return self.expressions(action="var") + "[" + self.expressions(action="pexpr") + "]"

            if action == "negvar":

                return self.expressions(action="peop1") + self.expressions(action="pexpr")

            if action == "exp":

                return self.expressions(action="pexpr") + self.expressions(action="peop2") + self.expressions(action="pexpr")

        if action == "peop1":

            return self.action_expressions.get_action(sub="peop1")

        if action == "peop2":

            return self.action_expressions.get_action(sub="peop2")

        if action == "var" or action == "ident":

            return "~some variable~"

    """

        INSTRUCTIONS

    """

    def instructions(self, action=None):

        if action is None:

            action = self.action_instructions.get_action()

        if action == "pinstr":

            action = self.action_instructions.get_action(sub="pinstr")

            if action == "arrayinit":

                return "arrayinit"  #TODO what is arrayinit?

            if action == "if":

                return "if " + self.expressions(action="pexpr") + self.instructions(action="pblock")

            if action == "ifelse":

                return "if " + self.expressions(action="pexpr") + self.instructions(action="pblock") \
                        + " else " + self.instructions(action="pblock")

            if action == "forto":

                return "for " + self.expressions(action="var") + " = " + self.expressions(action="pexpr") + " to "\
                        + self.expressions(action="pexpr") + self.instructions(action="pblock")

            if action == "fordown":

                return "for " + self.expressions(action="var") + " = " + self.expressions(action="pexpr") + " downto " \
                        + self.expressions(action="pexpr") + self.instructions(action="pblock")

            if action == "while":

                return "while " + self.instructions(action="pblock") + "{\n" + self.expressions(action="pexpr") + "}" \
                        + self.instructions(action="pblock")

        if action == "pblock":

            return "(<var><peqop><var>)"  #TODO make such that it return <var><peqop><var>

        if action == "peqop":

            return self.action_instructions.get_action(sub="peqop")

        if action == "plvalue":

            action = self.action_instructions.get_action(sub="plvalue")

            if action == "_":

                return "_"

            if action == "var":

                return self.expressions(action="var")

            if action == "array":

                return self.expressions(action="var") + "[" + self.expressions(action="pexpr") + "]"

    """
    
        FUNCTIONS
    
    """

    def functions(self, action=None):

        if action is None:

            action = self.action_functions.get_action()

        if action == "pfunbody":

            return "{\n" + self.functions(action="pvardecl") + self.instructions("pinstr") + "\nreturn " + self.functions(action="return") + ";\n}"

        if action == "storage":

            return self.action_functions.get_action(sub="storage")

        if action == "stor_type":

            return self.functions(action="storage") + " " + self.types(action="ptype")

        if action == "pvardecl":

            return self.functions(action="stor_type") + " " + self.expressions(action="var") + ";\n"

        if action == "return":

            return "return_variable"  # can be a tuple

    """
    
        TYPESS
    
    """

    def types(self, action=None):

        if action is None:

            action = self.action_types.get_action()

        if action == "ptype":

            action = self.action_types.get_action(sub="ptype")

            if action == "bool":

                return "bool"

            if action == "int":

                return "int"

            if action == "utype":

                return self.types(action="utype")

            else:

                return self.types(action="utype") + self.types(action="utype") + "[" + self.expressions(action="pexpr") + "]"


        else:

            return  self.action_types.get_action(sub="utype")







