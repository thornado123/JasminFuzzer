"""

    The Jasmin program generator is a deterministic Jasmin source program generator
    that take a seed token and generates a program with offset in this token.


    Methods:

        __init__:

            - set the current seed value

        getProgram:

            - given a seed value return a valid Jasmin program


    Jasmin BNF:

    TYPES:

    <ptype>     ::= T_BOOL | T_INT | <utype> | <utype><brackets <pexpr>>
    <utype>     ::= T_U8 | T_U16 | T_U32 | T_U64 | T_U128 | T_U256


    EXPRESSIONS:

    <pexpr>     ::= <var> | <var><brackets<pexpr>> | TRUE | FALSE | INT | [<parens<ptype>>]<brackets(<var>+<pexpr>)>
                | <peop1><pexpr> | <pexpr><peop2><pexpr> | <parens<pexpr>> | <var><parens_tuple<pexpr>>
                | <prim><parens_tuple<pexpr>>

    <ident>     ::= NID
    <var>       ::= <ident>
    <prim>      ::= #<ident>

    <peop1>     ::= ! | -
    <peop2>     ::= + | - | * | && | PIPEPIPE | & | PIPE | ^ | << | >> | >>s | == | != | < | <= | > | >= | <s | <=s | >s
                | >=s

    INSTRUCTIONS:

    <pinstr>    ::= ARRAYINIT ⟨parens⟨var⟩⟩ ;
                | ⟨tuple1⟨plvalue⟩⟩ ⟨peqop⟩ ⟨pexpr⟩ [IF ⟨pexpr⟩] ; | ⟨var⟩ ⟨parens_tuple⟨pexpr⟩⟩ ;
                | IF ⟨pexpr⟩ ⟨pblock⟩
                | IF ⟨pexpr⟩ ⟨pblock⟩ ELSE ⟨pblock⟩
                | FOR ⟨var⟩ = ⟨pexpr⟩ TO ⟨pexpr⟩ ⟨pblock⟩
                | FOR ⟨var⟩ = ⟨pexpr⟩ DOWNTO ⟨pexpr⟩ ⟨pblock⟩ | WHILE [⟨pblock⟩] ⟨parens⟨pexpr⟩⟩ [⟨pblock⟩]

    <pblock>    ::= ⟨braces⟨pinstr⟩*⟩

    <peqop>     ::= =
                | += | -= | *=
                | >>= |>>s= |<<=
                | &= |^= | PIPEEQ

    <plvalue>   ::= UNDERSCORE | <var> | <var> <brackets<pexpr>> | [<parens<ptype>>]<brackets(<var> + <pexpr>)>

    FUNCTIONS:

    <pfunbody>  ::= LBRACE (⟨pvardecl⟩ ;)∗ ⟨pinstr⟩∗ [RETURN ⟨tuple⟨var⟩⟩ ;] RBRACE

    <storage>   ::= REG | STACK | INLINE

    <stor_type> ::= <storage><ptype>
    <pvardecl>  ::= <stor_type><var>


    GLOBAL DECLARATIONS:

    <module>    ::= <top> * EOF | error
    <top>       ::= <pfundef> | <pparam> | <pglobal>
    <call_conv> ::= EXPORT | INLINE //Inline is default
    <pfundef>   ::= [<call_conv>]FN <ident> <parens_tuple(<stor_type><var>)>[-><tuple<stor_type>>]<pfunbody>
    <pparam>    ::= PARAM <ptype><ident> = <pexpr>;
    <pglobal>   ::= <ident> = <pexpr>;

"""

import numpy as np
from datetime import datetime

import jasminDistribution as JD
from jasminNonterminalAndTokens import Nonterminals as JN
from jasminScopes import Scopes as JS
from jasminTypes import JasminTypes as JT


class JasminGenerator:

    def __init__(self, program_seed):

        self.seed               = program_seed
        self.action_global      = JD.GlobalDeclarations(self.seed)
        self.action_types       = JD.Types(self.seed)
        self.action_functions   = JD.Functions(self.seed)
        self.action_expressions = JD.Expressions(self.seed)
        self.action_instructions= JD.Instructions(self.seed)

        self.function_return = False
        self.return_types = []

        self.variable_types = {}
        self.variables_of_type = {}

        self.variables = {

            JS.Variables    : [],
            JS.Arrays       : [],
            JS.Function_name: [],
            JS.Decl         : []

        }

    def get_program(self):

        program = ["// Program seed: ", str(self.seed), "\n", "// Generated by JasminFuzzer on ",
                   str(datetime.now()), " \n\n"]

        amount_of_global_decls = 1 # self.action_prop(self.seed, "global")

        for _ in range(amount_of_global_decls):

            program += self.global_declarations()

        """
            
            Adding string rep. of the different types
            
        """

        program = self.clean_types(program)

        """
        
            Removing unused variables
        
        """

        program = self.remove_unused_variables(program)

        return program

    def clean_types(self, program_list):

        for i in range(len(program_list)):

            part =  program_list[i]

            if isinstance(part, JT):

                program_list[i] = part.name.lower()

        return program_list

    def remove_unused_variables(self, program_list):

        for var in self.variable_types.keys():

            if program_list.count(var) == 1:
                if var == "v0":
                    print("Special case v0")
                else:
                    index = program_list.index(var)
                    program_list[index + 1] = ""
                    program_list[index]     = ""
                    program_list[index - 1] = ""
                    program_list[index - 2] = ""
                    program_list[index - 3] = ""
                    program_list[index - 4] = ""

        return program_list

    def get_variable(self, scope, evaluation_type=None):

#        print("scope: ", scope, evaluation_type)

        if scope == JS.Arrays:

            types_array = [x for x in self.variables[JS.Arrays] if self.variable_types[x] == evaluation_type]

            if len(types_array) == 0:
                return None

            else:

                result = np.random.choice(types_array, 1, replace=False)
                return result[0]

        if scope == JS.Variables:

            index = np.random.choice(self.variables[JS.Variables], 1, replace=False)
            return index[0]

        if scope == JS.Decl:

            new_var = "v"

            if len(self.variables[JS.Variables]) == 0:

                self.variables[JS.Variables] = [new_var + "0"]
                return new_var + "0"

            else:

                new_var = new_var + str(len(self.variables[JS.Variables]))
                self.variables[JS.Variables].append(new_var)

                return new_var

        if scope == JS.Function_name:

            if self.variables[JS.Function_name] == 0:

                new_func = "f0"
                self.variables[JS.Function_name] = [new_func]
                return new_func

            else:

                new_func = "f" + str(len(self.variables[JS.Function_name]))
                self.variables[JS.Function_name].append(new_func)

                return new_func

        else:

            #print("scope", scope)
            #print(self.variables_of_type.keys())
            #print(self.variable_types.keys())
            #print(self.variables_of_type[scope])
            #print(len(self.variables_of_type[scope]) > 1 and isinstance(self.variables_of_type[scope], list))
            if scope in self.variables_of_type:
                if len(self.variables_of_type[scope]) > 1 and isinstance(self.variables_of_type[scope], list):
                    return np.random.choice(self.variables_of_type[scope], 1, replace=False)[0]
                else:
                    return self.variables_of_type[scope]
            else:

                return None

    """
    
        Global decl. 
        
        Is at depth 0
        
    """

    def global_declarations(self, action=None):

        if action is None:

            action = self.action_global.get_action()
            return self.global_declarations(action=action)

        elif action == JN.Module:

            action = self.action_global.get_action(JN.Module)

            if action == JN.Top:

                return [self.global_declarations(JN.Top), " * EOF"]

            else:

                return "error"

        elif action == JN.Top:

            action = self.action_global.get_action(JN.Top)

            if action == JN.Pfundef:

                return self.global_declarations(JN.Pfundef)

            if action == JN.Param:

                return self.global_declarations(JN.Param)

            if action == JN.Pglobal:

                return self.global_declarations(JN.Pglobal)

        elif action == JN.Call_conv:

            action = self.action_global.get_action(JN.Call_conv)

            if action == "export":

                return "export"

            else:

                return "inline"  # inline is default

        elif action == JN.Pfundef:

            decl            = self.global_declarations(action=JN.Call_conv)
            function_name   = self.expressions(action=JN.Ident, scope=JS.Function_name, r_depth=0)
            input_param     = self.expressions(action=JN.Var, scope=JS.Decl, r_depth=0)
            input_param_type= self.functions(action=JN.Stor_type, r_depth=0)

            if len(input_param_type) >= 3:
                self.variables[JS.Arrays].append(input_param)


            #print("Pfundef: ", input_param, input_param_type[2])

            self.variable_types[input_param]            = input_param_type[2]
            self.variables_of_type[input_param_type[2]] = [input_param]

            result = [decl, " "]
            result += ["fn ", function_name, "("]
            result += input_param_type
            result.append(" ")
            result.append(input_param)
            result.append(")")

            if self.action_functions.get_action(sub="return"):
                return_type = self.functions(action=JN.Stor_type, r_depth=0)

                result.append(" -> ")
                result += return_type                                                                                   #TODO can be a tuple

                self.function_return = True
                self.return_types = return_type[1]

            result += self.functions(action=JN.Pfunbody, r_depth=0)

            if self.function_return:

                return_var      = self.get_variable(scope=JS.Variables)
                return_var_type = self.variable_types[return_var]

                if return_var in self.variables[JS.Arrays]:
                    index = 15
                    if "v0" in self.variables[JS.Arrays]:
                        index += 1
                    result[index] = "[5]" + result[index]

                result[14] = return_var_type
                result[-3] = return_var


            return result

        elif action == JN.Param:

            return [JN.Param, self.types(action=JN.Ptype), self.expressions(action=JN.Ident, r_depth=0),
                    " = ", self.expressions(action=JN.Pexpr, r_depth=0)]

        elif action == JN.Pglobal:
            var         = self.expressions(action=JN.Ident, r_depth=0)
            var_type    = self.variable_types[var]
            value       = self.expressions(action=JN.Pexpr, scope=var_type, evaluation_type=var_type, r_depth=0)
            result      = [var, "="]

            if isinstance(value, list):
                result += value
            else:
                result.append(value)

            return result

        else:

            raise Exception("GLOBAL DECLARATION NO MATCH")

    """
    
        EXPRESSIONS
        
        Are at a variable level as they can be recursively defined
    
    """

    def expressions(self, action=None, evaluation_type=None, scope=None, r_depth=0):

#     print("Expression", r_depth, "->", action, " scope ", scope, "ev type", evaluation_type)

        r_depth = r_depth + 1
        #print(r_depth)

        if action == JN.Pexpr:

            action = self.action_expressions.get_action(sub=JN.Pexpr, scope=scope, r_depth=r_depth)
            #print("Pexpr ", action, scope)

            """
            
                Terminating actions
            
            """

            if action == "true" or action == "false":

                if scope != JT.BOOL:
                   # print("TRUE/FALSE: ", scope, evaluation_type)
                    return self.expressions(action=JN.Pexpr, scope=scope, evaluation_type=evaluation_type)

                elif action == "true":

                    return ["true"]

                elif action == "false":

                    return ["false"]

            if action == "int":

                if evaluation_type == JT.BOOL:

                    return self.expressions(action=JN.Pexpr, scope=scope, evaluation_type=evaluation_type)

                else:

                    return ["32123"]                                                                                    #TODO should be a random int

            if action == JN.Var:
               # print("JN Var: ", scope)

                result = self.expressions(action=JN.Var, scope=scope, r_depth=r_depth)

                if result is None:
                    return self.expressions(action=JN.Pexpr, scope=scope, evaluation_type=evaluation_type, r_depth=r_depth)

                else:

                    return result

            """
            
                Branching actions
            
            """

            if action == "array":

                """
                
                    If there do not exist a declared array variable then this is a bad call 
                
                """

                var = self.expressions(action=JN.Var, scope=JS.Arrays, evaluation_type=evaluation_type, r_depth=r_depth)

                if var is not None:

                    result = [var, "["]
                    exp = self.expressions(action=JN.Pexpr, scope=JT.INT, evaluation_type=JT.INT, r_depth=r_depth)
                    if isinstance(exp, list):
                        result += exp
                    else:
                        result.append(exp)
                    result.append("]")

                    return result

                else:

                    return self.expressions(action=JN.Pexpr, scope=scope, evaluation_type=evaluation_type, r_depth=r_depth)

            if action == "negvar":

                exp = self.expressions(action=JN.Pexpr, scope=scope, evaluation_type=evaluation_type, r_depth=r_depth)
                opera = self.expressions(action=JN.Peop1, scope=scope, evaluation_type=evaluation_type, r_depth=r_depth)
                result = ["("]
                result.append(opera)
                if isinstance(exp, list):
                    result += exp
                else:
                    result.append(exp)
                result.append(")")

                return result

            if action == "exp":

                if evaluation_type == JT.BOOL:

                    new_ev_type = self.action_types.get_action(sub="eval_type")

                else:

                    new_ev_type = evaluation_type

                if new_ev_type != JT.BOOL and evaluation_type == JT.BOOL:                                               #TODO this should be cleaned as standised

                    operator = "compare"

                else:

                    operator = evaluation_type

                exp1 = self.expressions(action=JN.Pexpr, scope=new_ev_type, evaluation_type=new_ev_type, r_depth=r_depth)
                opera = self.expressions(action=JN.Peop2, scope=scope, evaluation_type=operator, r_depth=r_depth)
                exp2 = self.expressions(action=JN.Pexpr, scope=new_ev_type, evaluation_type=new_ev_type, r_depth=r_depth)

                result = ["("]
                if isinstance(exp1, list):
                    result += exp1
                else:
                    result.append(exp1)
                result.append(opera)
                if isinstance(exp2, list):
                    result += exp2
                else:
                    result.append(exp2)
                result.append(")")

                return result

        if action == JN.Peop1:

            if evaluation_type == JT.BOOL:

                return "!"

            else:

                return "-"

        if action == JN.Peop2:

            if evaluation_type == JT.BOOL:

                return self.action_expressions.get_action(sub="logic")

            if evaluation_type == "compare":

                return self.action_expressions.get_action(sub="compare")

            else:

                return self.action_expressions.get_action(sub="artemtic")

        if action == JN.Var:

            return self.expressions(action=JN.Ident, scope=scope, evaluation_type=evaluation_type, r_depth=r_depth)

        if action == JN.Ident:
           # print("scope", scope)
            return self.get_variable(scope, evaluation_type=evaluation_type)

        raise Exception("EXPRESSION NO MATCH")

    """

        INSTRUCTIONS

    """

    def instructions(self, action=None, r_depth=0, scope=None):

        #print("Instruction", r_depth, "->", action, scope)

        if action == JN.Pinstr:

            action = self.action_instructions.get_action(sub=JN.Pinstr, r_depth=r_depth)

            if action == "arrayinit":

                return ["v0 += 1;"]                                                                                     #TODO what is arrayinit?

            if action == "assign":

                var_to_assign = self.instructions(action=JN.Plvalue, r_depth=r_depth, scope=JS.Variables)

                if var_to_assign == "_":

                    ev_type = self.action_types.get_action(sub="assign_type")

                elif isinstance(var_to_assign, list):

                    ev_type = self.variable_types[var_to_assign[0]]

                else:

                    ev_type = self.variable_types[var_to_assign]


                assign_op      = self.instructions(action=JN.Peqop, scope=ev_type)
                value_to_assign= self.expressions(action=JN.Pexpr, scope=JS.Variables, evaluation_type=ev_type)

                if isinstance(var_to_assign, list):
                    result = var_to_assign
                else:
                    result = [var_to_assign]

                result.append(assign_op)
                result += value_to_assign
                result.append(";")

                return result

            if action == "if":

                result = ["if "]
                condition = self.expressions(action=JN.Pexpr, scope=JT.BOOL, evaluation_type=JT.BOOL, r_depth=r_depth)
                if isinstance(condition, list):
                    result += condition
                else:
                    result.append(condition)
                result += self.instructions(action=JN.Pblock, r_depth=r_depth, scope=JS.Variables)

                return result

            if action == "ifelse":

                result = ["if "]
                result += self.expressions(action=JN.Pexpr, scope=JT.BOOL, evaluation_type=JT.BOOL)
                result += self.instructions(action=JN.Pblock, r_depth=r_depth, scope=JS.Variables)
                result.append(" else ")
                result += self.instructions(action=JN.Pblock, r_depth=r_depth, scope=JS.Variables)

                return result

            if action == "forto" or action == "fordown":

                if JT.INT.name.lower() in self.variables_of_type:

                    if action == "forto":

                        """
                            
                            They all need to be the same type
                        
                        """
                        first_var = self.expressions(action=JN.Var, scope=JT.INT)
                        second_var = self.expressions(action=JN.Pexpr, scope=JT.INT, evaluation_type=JT.INT)
                        third_var = self.expressions(action=JN.Pexpr, scope=JT.INT, evaluation_type=JT.INT)

                        return ["for ", first_var, " = ", second_var, " to ", third_var,
                                self.instructions(action=JN.Pblock, r_depth=r_depth)]

                    if action == "fordown":

                        """
        
                            They all need to be the same type
        
                        """
                        first_var = self.expressions(action=JN.Var, scope=JT.INT, evaluation_type=JT.INT)
                        var_type = self.variable_types[first_var]
                        second_var = self.expressions(action=JN.Pexpr, scope=JT.INT, evaluation_type=JT.INT)
                        third_var = self.expressions(action=JN.Pexpr, scope=JT.INT, evaluation_type=JT.INT)

                        return ["for ", first_var, " = ", second_var, " downto ", third_var,
                               self.instructions(action=JN.Pblock, r_depth=r_depth, scope=JS.Variables)]
                else:

                    return self.instructions(action=JN.Pinstr, scope=scope)

            if action == "while":

                start_end = self.action_instructions.get_action(sub="while")
                result = ["while "]
                if start_end:
                    result += self.instructions(action=JN.Pblock, r_depth=r_depth, scope=JS.Variables)

                result += "("
                bool_exp = self.expressions(action=JN.Pexpr, evaluation_type=JT.BOOL, scope=JT.BOOL)
                if isinstance(bool_exp, list):
                    result += bool_exp
                else:
                    result.append(bool_exp)
                result += ")"

                if not start_end:
                    result += self.instructions(action=JN.Pblock, r_depth=r_depth, scope=JS.Variables)

                return result

        if action == JN.Peqop:
            if scope == JT.BOOL:
                return self.action_instructions.get_action(sub="logic")
            else:
                return self.action_instructions.get_action(sub=JN.Peqop)                                                #TODO make such that it return <var><peqop><var>

        if action == JN.Pblock:

            result = ["{\n"]
            result += self.instructions(action=JN.Pinstr, scope=JS.Variables, r_depth=r_depth)
            result += ["\n}"]                                                                                           #TODO should be able to do multiple

            return result

        if action == JN.Plvalue:

            action = self.action_instructions.get_action(sub=JN.Plvalue, r_depth=r_depth)
           # print(action)
            if action == "_":

                return "_"

            if action == JN.Var:

                return self.expressions(action=JN.Var, r_depth=r_depth, scope=scope)

            if action == "array":
                var     = self.expressions(action=JN.Var, r_depth=r_depth, scope=scope)
                index   = self.expressions(action=JN.Pexpr, r_depth=r_depth, scope=JT.INT, evaluation_type=JT.INT)

                result = [var, "["]
                result += index
                result.append("]")

                return result

        raise Exception("INSTRUCTION NO MATCH")

    """
    
        FUNCTIONS
    
    """

    def functions(self, action=None, r_depth=0):

        #print("Func: ", r_depth, "->", action)

        r_depth = r_depth + 1

        if action == JN.Pfunbody:

            result          = ["{\n"]
            amount_of_vars  = range(self.action_functions.get_amount_of_decls())
            amount_of_incs  = range(self.action_functions.get_amount_of_instructions())

           # print("Amount of vars in func:", amount_of_vars)

            for _ in amount_of_vars:

                result += self.functions(action=JN.Pvardecl, r_depth=r_depth)

            for _ in amount_of_incs:

                result += self.instructions(JN.Pinstr, r_depth=r_depth, scope=JS.Variables)
                result += "\n"

            if self.function_return:

                #result += ["return ", self.functions(action="return", r_depth=r_depth), ";"]
                result += ["return ", None, ";"]
                #self.function_return = False

            result += ["\n}"]

            return result

        if action == JN.Storage:

            return self.action_functions.get_action(sub=JN.Storage, r_depth=r_depth)

        if action == JN.Stor_type:

            result = [self.functions(action=JN.Storage, r_depth=r_depth)," "]
            var_type = self.types(action=JN.Ptype)

            if isinstance(var_type, list):
                result += var_type
            else:
                result.append(var_type)

            #print(result)
            return result

        if action == JN.Pvardecl:

            stor_type = self.functions(action=JN.Stor_type, r_depth=r_depth)
            variable = self.expressions(action=JN.Var, scope=JS.Decl, r_depth=r_depth)
            var_type = stor_type[2]

            """
            
                If var_type is of the form <type><brackets> it should be added to arrays as well
            
            """
            self.variable_types[variable] = var_type

            if len(stor_type) > 3:

                self.variables[JS.Arrays].append(variable)

            if var_type in self.variables_of_type:

                self.variables_of_type[var_type].append(variable)

            else:

                self.variables_of_type[var_type] = [variable]

            result = stor_type
            result += [" ", variable, ";\n"]

            return result

        raise Exception("FUNCTION NO MATCH")

    """
    
        TYPES
    
    """

    def types(self, action=None, r_depth=0):

        r_depth = r_depth + 1

        if action == JN.Ptype:

            action = self.action_types.get_action(sub=JN.Ptype)

            if action == JT.BOOL:

                return JT.BOOL

            if action == JT.INT:

                return JT.INT

            if action == JN.Utype:

                return self.types(action=JN.Utype)

            if action == "array":

                return [self.types(action=JN.Utype), "[5]"]                                                             #TODO should be somekind of int declearing the size

        if action == JN.Utype:

            return self.action_types.get_action(sub=JN.Utype, r_depth=r_depth)

        raise Exception("TYPE NO MATCH")





