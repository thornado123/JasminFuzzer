"""

    The Jasmin program generator is a deterministic Jasmin source program generator
    that take a seed token and generates a program with offset in this token.


    Methods:

        __init__:

            - set the current seed value

        getProgram:

            - given a seed value return a valid Jasmin program


    Jasmin BNF:

    TYPES:

    <ptype>     ::= T_BOOL | T_INT | <utype> | <utype><brackets <pexpr>>
    <utype>     ::= T_U8 | T_U16 | T_U32 | T_U64 | T_U128 | T_U256


    EXPRESSIONS:

    <pexpr>     ::= <var> | <var><brackets<pexpr>> | TRUE | FALSE | INT | [<parens<ptype>>]<brackets(<var>+<pexpr>)>
                | <peop1><pexpr> | <pexpr><peop2><pexpr> | <parens<pexpr>> | <var><parens_tuple<pexpr>>
                | <prim><parens_tuple<pexpr>>

    <ident>     ::= NID
    <var>       ::= <ident>
    <prim>      ::= #<ident>

    <peop1>     ::= ! | -
    <peop2>     ::= + | - | * | && | PIPEPIPE | & | PIPE | ^ | << | >> | >>s | == | != | < | <= | > | >= | <s | <=s | >s
                | >=s

    INSTRUCTIONS:

    <pinstr>    ::= ARRAYINIT ⟨parens⟨var⟩⟩ ;
                | ⟨tuple1⟨plvalue⟩⟩ ⟨peqop⟩ ⟨pexpr⟩ [IF ⟨pexpr⟩] ; | ⟨var⟩ ⟨parens_tuple⟨pexpr⟩⟩ ;
                | IF ⟨pexpr⟩ ⟨pblock⟩
                | IF ⟨pexpr⟩ ⟨pblock⟩ ELSE ⟨pblock⟩
                | FOR ⟨var⟩ = ⟨pexpr⟩ TO ⟨pexpr⟩ ⟨pblock⟩
                | FOR ⟨var⟩ = ⟨pexpr⟩ DOWNTO ⟨pexpr⟩ ⟨pblock⟩ | WHILE [⟨pblock⟩] ⟨parens⟨pexpr⟩⟩ [⟨pblock⟩]

    <pblock>    ::= ⟨braces⟨pinstr⟩*⟩

    <peqop>     ::= =
                | += | -= | *=
                | >>= |>>s= |<<=
                | &= |^= | PIPEEQ

    <plvalue>   ::= UNDERSCORE | <var> | <var> <brackets<pexpr>> | [<parens<ptype>>]<brackets(<var> + <pexpr>)>

    FUNCTIONS:

    <pfunbody>  ::= LBRACE (⟨pvardecl⟩ ;)∗ ⟨pinstr⟩∗ [RETURN ⟨tuple⟨var⟩⟩ ;] RBRACE

    <storage>   ::= REG | STACK | INLINE

    <stor_type> ::= <storage><ptype>
    <pvardecl>  ::= <stor_type><var>


    GLOBAL DECLARATIONS:

    <module>    ::= <top> * EOF | error
    <top>       ::= <pfundef> | <pparam> | <pglobal>
    <call_conv> ::= EXPORT | INLINE //Inline is default
    <pfundef>   ::= [<call_conv>]FN <ident> <parens_tuple(<stor_type><var>)>[-><tuple<stor_type>>]<pfunbody>
    <pparam>    ::= PARAM <ptype><ident> = <pexpr>;
    <pglobal>   ::= <ident> = <pexpr>;

"""

import jasminDistribution as JD
from datetime import datetime


class JasminGenerator:

    def __init__(self, program_seed):

        self.seed               = program_seed
        self.action_global      = JD.GlobalDeclarations(self.seed)
        self.action_types       = JD.Types(self.seed)
        self.action_functions   = JD.Functions(self.seed)

    def getProgram(self):

        program = "// Program seed: " + str(self.seed) + "\n" \
                + "// Generated by JasminFuzzer on " + str(datetime.now()) + " \n\n"

        amount_of_global_decls = 1  # self.action_prop(self.seed, "global")

        for _ in range(amount_of_global_decls):

            program += self.global_declarations()

        return program

    def global_declarations(self, action=None):

        if action is None:

            action = self.action_global.get_action()

        if action == "module":

            action = self.action_global.get_action("module")

            if action == "top":

                return self.global_declarations("top")+" * EOF"

            else:

                return "error"

        if action == "top":

            action = self.action_global.get_action("top")

            if action == "pfundef":

                return self.global_declarations("pfundef")

            if action == "pparam":

                return self.global_declarations("pparam")

            if action == "pglobal":

                return self.global_declarations("pglobal")

        if action == "call_conv":

            action = self.action_global.get_action("call_conv")

            if action == "export":

                return "export"

            else:

                return ""  # inline is default

        if action == "pfundef":


            return self.global_declarations(action="call_conv") + " fn " + self.expressions(action="ident") + \
                    "(" + self.functions(action="stor_type") \
                    + self.expressions(action="var") + ") -> (" \
                    + self.functions(action="stor_type") + ")" \
                    + self.functions(action="pfunbody")


        if action == "pparam":

            return "param" + self.types(action="ptype") + self.expressions(action="ident") + " = " + self.expressions(action="pexpr")

        if action == "pglobal":

            return self.expressions(action="ident") + " = " + self.expressions(action="pexpr")

    """
    
        EXPRESSIONS
    
    """

    < pexpr >::= < var > | < var > < brackets < pexpr >> | [ < parens < ptype >>] < brackets( < var > + < pexpr >) >
    | < peop1 > < pexpr > | < pexpr > < peop2 > < pexpr > | < parens < pexpr >> | < var > < parens_tuple < pexpr >>
    | < prim > < parens_tuple < pexpr >>

< ident >::= NID
< var >::= < ident >
< prim >::=  # <ident>

< peop1 >::= ! | -
< peop2 >::= + | - | * | & & | PIPEPIPE | & | PIPE | ^ | << | >> | >> s | == | != | < | <= | > | >= | < s | <= s | > s
| >= s


    def expressions(self, action=None):





    """

        INSTRUCTIONS

    """

    def instructions(self, action=None):

        return "instruction"

    """
    
        FUNCTIONS
    
    """

    def functions(self, action=None):

        if action is None:

            action = self.action_functions.get_action()

        if action == "pfunbody":

            return "{\n" + self.functions(action="pvardecl") + self.instructions("pinstr") + "\nreturn " + self.functions(action="return") + ";\n}"

        if action == "storage":

            return self.action_functions.get_action(sub="storage")

        if action == "stor_type":

            return self.functions(action="storage") + " " + self.types(action="ptype")

        if action == "pvardecl":

            return self.functions(action="stor_type") + " " + self.expressions(action="var") + ";\n"

        if action == "return":

            return "return_variable"  # can be a tuple

    def types(self, action=None):

        if action is None:

            action = self.action_types.get_action()

        if action == "ptype":

            action = self.action_types.get_action(sub="ptype")

            if action == "bool":

                return "bool"

            if action == "int":

                return "int"

            if action == "utype":

                return self.types(action="utype")

            else:

                return self.types(action="utype") + self.types(action="utype") + "[" + self.expressions(action="pexpr") + "]"


        else:

            return  self.action_types.get_action(sub="utype")







