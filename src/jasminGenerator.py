"""

    The Jasmin program generator is a deterministic Jasmin source program generator
    that take a seed token and generates a program with offset in this token.


    Methods:

        __init__:

            - set the current seed value

        getProgram:

            - given a seed value return a valid Jasmin program


    Jasmin BNF:

    TYPES:

    <ptype>     ::= T_BOOL | T_INT | <utype> | <utype><brackets <pexpr>>
    <utype>     ::= T_U8 | T_U16 | T_U32 | T_U64 | T_U128 | T_U256


    EXPRESSIONS:

    <pexpr>     ::= <var> | <var><brackets<pexpr>> | TRUE | FALSE | INT | [<parens<ptype>>]<brackets(<var>+<pexpr>)>
                | <peop1><pexpr> | <pexpr><peop2><pexpr> | <parens<pexpr>> | <var><parens_tuple<pexpr>>
                | <prim><parens_tuple<pexpr>>

    <ident>     ::= NID
    <var>       ::= <ident>
    <prim>      ::= #<ident>

    <peop1>     ::= ! | -
    <peop2>     ::= + | - | * | && | PIPEPIPE | & | PIPE | ^ | << | >> | >>s | == | != | < | <= | > | >= | <s | <=s | >s
                | >=s

    INSTRUCTIONS:

    <pinstr>    ::= ARRAYINIT ⟨parens⟨var⟩⟩ ;
                | ⟨tuple1⟨plvalue⟩⟩ ⟨peqop⟩ ⟨pexpr⟩ [IF ⟨pexpr⟩] ; | ⟨var⟩ ⟨parens_tuple⟨pexpr⟩⟩ ;
                | IF ⟨pexpr⟩ ⟨pblock⟩
                | IF ⟨pexpr⟩ ⟨pblock⟩ ELSE ⟨pblock⟩
                | FOR ⟨var⟩ = ⟨pexpr⟩ TO ⟨pexpr⟩ ⟨pblock⟩
                | FOR ⟨var⟩ = ⟨pexpr⟩ DOWNTO ⟨pexpr⟩ ⟨pblock⟩ | WHILE [⟨pblock⟩] ⟨parens⟨pexpr⟩⟩ [⟨pblock⟩]

    <pblock>    ::= ⟨braces⟨pinstr⟩*⟩

    <peqop>     ::= =
                | += | -= | *=
                | >>= |>>s= |<<=
                | &= |^= | PIPEEQ

    <plvalue>   ::= UNDERSCORE | <var> | <var> <brackets<pexpr>> | [<parens<ptype>>]<brackets(<var> + <pexpr>)>

    FUNCTIONS:

    <pfunbody>  ::= LBRACE (⟨pvardecl⟩ ;)∗ ⟨pinstr⟩∗ [RETURN ⟨tuple⟨var⟩⟩ ;] RBRACE

    <storage>   ::= REG | STACK | INLINE

    <stor_type> ::= <storage><ptype>
    <pvardecl>  ::= <stor_type><var>


    GLOBAL DECLARATIONS:

    <module>    ::= <top> * EOF | error
    <top>       ::= <pfundef> | <pparam> | <pglobal>
    <call_conv> ::= EXPORT | INLINE //Inline is default
    <pfundef>   ::= [<call_conv>]FN <ident> <parens_tuple(<stor_type><var>)>[-><tuple<stor_type>>]<pfunbody>
    <pparam>    ::= PARAM <ptype><ident> = <pexpr>;
    <pglobal>   ::= <ident> = <pexpr>;

"""

import numpy as np
from datetime import datetime

import jasminDistribution as JD
from jasminNonterminalAndTokens import Nonterminals as JN
from jasminScopes import Scopes as JS
from jasminTypes import JasminTypes as JT

class JasminGenerator:

    def __init__(self, program_seed):

        self.seed               = program_seed
        self.action_global      = JD.GlobalDeclarations(self.seed)
        self.action_types       = JD.Types(self.seed)
        self.action_functions   = JD.Functions(self.seed)
        self.action_expressions = JD.Expressions(self.seed)
        self.action_instructions= JD.Instructions(self.seed)

        self.function_return = False
        self.return_types = []

        self.variable_types = {}
        self.variables_of_type = {}

        self.variables = {

            JS.Variables    : [],
            JS.Arrays       : [],
            JS.Function_name: [],
            JS.Decl         : []

        }

    def get_program(self):

        program = ["// Program seed: ", str(self.seed), "\n", "// Generated by JasminFuzzer on ",
                   str(datetime.now()), " \n\n"]

        amount_of_global_decls = 1 # self.action_prop(self.seed, "global")

        for _ in range(amount_of_global_decls):

            program += self.global_declarations()

        return program

    def get_variable(self, scope, evaluation_type=None):

        print("scope: ", scope, evaluation_type)

        if scope == JS.Arrays:

            types_array = [x for x in self.variables[JS.Arrays] if self.variable_types[x] == evaluation_type]

            if len(types_array) == 0:

                return None

            else:

                return np.random.choice(types_array, 1, replace=False)

        if scope == JS.Variables:

            index = np.random.choice(self.variables[JS.Variables], 1, replace=False)
            return index[0]

        if scope == JS.Decl:

            new_var = "v"

            if len(self.variables[JS.Variables]) == 0:

                self.variables[JS.Variables] = [new_var + "0"]
                return new_var + "0"

            else:

                new_var = new_var + str(len(self.variables[JS.Variables]))
                self.variables[JS.Variables].append(new_var)

                return new_var

        if scope == JS.Function_name:

            if self.variables[JS.Function_name] == 0:

                new_func = "f0"
                self.variables[JS.Function_name] = [new_func]
                return new_func

            else:

                new_func = "f" + str(len(self.variables[JS.Function_name]))
                self.variables[JS.Function_name].append(new_func)

                return new_func

        else:
            try:

                if scope == JT.BOOL or scope == JT.INT:

                    if scope.name.lower() in self.variables_of_type:

                        return np.random.choice(self.variables_of_type[scope.name.lower()], 1, replace=False)[0]

                    else:

                        return None

                else:

                    return np.random.choice(self.variables_of_type[scope], 1, replace=False)[0]

            except:

                    return np.random.choice(self.variables_of_type[scope.name.lower()], 1, replace=False)[0]

    """
    
        Global decl. 
        
        Is at depth 0
        
    """

    def global_declarations(self, action=None):

        if action is None:

            action = self.action_global.get_action()

            return self.global_declarations(action=action)

        elif action == JN.Module:

            action = self.action_global.get_action(JN.Module)

            if action == JN.Top:

                return [self.global_declarations(JN.Top), " * EOF"]

            else:

                return "error"

        elif action == JN.Top:

            action = self.action_global.get_action(JN.Top)

            if action == JN.Pfundef:

                return self.global_declarations(JN.Pfundef)

            if action == JN.Param:

                return self.global_declarations(JN.Param)

            if action == JN.Pglobal:

                return self.global_declarations(JN.Pglobal)

        elif action == JN.Call_conv:

            action = self.action_global.get_action(JN.Call_conv)

            if action == "export":

                return "export"

            else:

                return "inline"  # inline is default

        elif action == JN.Pfundef:

            result = []
            decl = self.global_declarations(action=JN.Call_conv)

            if decl != "inline":
                result += [decl, " "]

            function_name = self.expressions(action=JN.Ident, scope=JS.Function_name, r_depth=0)

            result += [
                        "fn ", function_name, "(",
                        self.functions(action=JN.Stor_type, r_depth=0), " ",
                        self.expressions(action=JN.Var, scope=JS.Decl, r_depth=0), ")"
                    ]

            if self.action_functions.get_action(sub="return"):
                return_type = self.functions(action=JN.Stor_type, r_depth=0)
                result += [" -> ", return_type]                                   #TODO can be a tuple

                self.function_return = True
                self.return_types = return_type.split(" ")[1]

            result += self.functions(action=JN.Pfunbody, r_depth=0)

            return result

        elif action == JN.Param:

            return [JN.Param, self.types(action=JN.Ptype), self.expressions(action=JN.Ident, r_depth=0),
                    " = ", self.expressions(action=JN.Pexpr, r_depth=0)]

        elif action == JN.Pglobal:

            return [self.expressions(action=JN.Ident, r_depth=0), " = ", self.expressions(action=JN.Pexpr, r_depth=0)]

        else:

            raise Exception("GLOBAL DECLARATION NO MATCH")

    """
    
        EXPRESSIONS
        
        Are at a variable level as they can be recursively defined
    
    """

    def expressions(self, action=None, evaluation_type=None, scope=None, r_depth=0):

        #print("Expression", r_depth, "->", action, scope)

        r_depth = r_depth + 1

        if action == JN.Pexpr:

            action = self.action_expressions.get_action(sub=JN.Pexpr, scope=scope, r_depth=r_depth)


            """
            
                Terminating actions
            
            """

            if action == "true" or action == "false":

                if scope != JT.BOOL:

                    return self.expressions(action=JN.Pexpr, scope=scope, evaluation_type=evaluation_type)

                if action == "true":

                    return ["true"]

                if action == "false":

                    return ["false"]

            if action == "int":

                if r_depth == 1 and evaluation_type == JT.BOOL:

                    return self.expressions(action=JN.Pexpr, scope=scope, evaluation_type=evaluation_type)

                else:

                    return ["32123"]

            if action == JN.Var:

                result = self.expressions(action=JN.Var, scope=scope, r_depth=r_depth)

                if result is None:

                    return self.expressions(action=JN.Pexpr, scope=scope, evaluation_type=evaluation_type, r_depth=r_depth)

                else:

                    return result

            """
            
                Branching actions
            
            """

            if action == "array":

                """
                
                    If there do not exist a declared array variable then this is a bad call 
                
                """

                var = self.expressions(action=JN.Var, scope=JS.Arrays, evaluation_type=evaluation_type, r_depth=r_depth)

                if var is not None:

                    result = [var, "["]
                    result += self.expressions(action=JN.Pexpr, scope=JT.INT, r_depth=r_depth)
                    result += ["]"]

                    return result

                else:

                    return self.expressions(action=JN.Pexpr, scope=scope, evaluation_type=evaluation_type, r_depth=r_depth)

            if action == "negvar":

                print(scope, evaluation_type)

                exp = self.expressions(action=JN.Pexpr, scope=scope, evaluation_type=evaluation_type, r_depth=r_depth)
                opera = self.expressions(action=JN.Peop1, scope=scope, evaluation_type=evaluation_type, r_depth=r_depth)
                result = ["("]
                result += opera
                result += exp
                result += ")"

                return result

            if action == "exp":

                if evaluation_type == JT.BOOL:

                    new_ev_type = self.action_types.get_action(sub="eval_type")

                else:

                    new_ev_type = evaluation_type

                if new_ev_type != JT.BOOL and evaluation_type == JT.BOOL: #TODO this should be cleaned as standised

                    operator = "compare"

                else:

                    operator = evaluation_type

                print(new_ev_type, evaluation_type)

                exp1 = self.expressions(action=JN.Pexpr, scope=new_ev_type, evaluation_type=new_ev_type, r_depth=r_depth)

                opera = self.expressions(action=JN.Peop2, scope=scope, evaluation_type=operator, r_depth=r_depth)

                exp2 = self.expressions(action=JN.Pexpr, scope=new_ev_type, evaluation_type=new_ev_type, r_depth=r_depth)

                result = ["("]
                result += exp1
                result += opera
                result += exp2
                result += ")"

                return result

        if action == JN.Peop1:

            if evaluation_type == JT.BOOL:

                return "!"

            else:

                return "-"

        if action == JN.Peop2:

            if evaluation_type == JT.BOOL:

                return self.action_expressions.get_action(sub="logic")

            if evaluation_type == "compare":

                return self.action_expressions.get_action(sub="compare")

            else:

                return self.action_expressions.get_action(sub="artemtic")

        if action == JN.Var:

            return self.expressions(action=JN.Ident, scope=scope, evaluation_type=evaluation_type, r_depth=r_depth)

        if action == JN.Ident:

            return self.get_variable(scope, evaluation_type=evaluation_type)

        raise Exception("EXPRESSION NO MATCH")

    """

        INSTRUCTIONS

    """

    def instructions(self, action=None, r_depth=0, scope=None):

        print("Instruction", r_depth, "->", action, scope)

        if action == JN.Pinstr:

            action = self.action_instructions.get_action(sub=JN.Pinstr, r_depth=r_depth)

            if action == "arrayinit":

                return ["v0 += 1;"]  #TODO what is arrayinit?

            if action == "assign":

                var_to_assign  = self.instructions(action=JN.Plvalue, r_depth=r_depth, scope=JS.Variables)

                if var_to_assign == "_":

                    ev_type = self.action_types.get_action(sub="eval_type")

                else:

                    ev_type = self.variable_types[var_to_assign]

                assign_op      = self.instructions(action=JN.Peqop)
                value_to_assign = self.expressions(action=JN.Pexpr, scope=JS.Variables, evaluation_type=ev_type)

                result = [var_to_assign]
                result += assign_op
                result += value_to_assign
                result += ";"

                return result

            if action == "if":

                result = ["if "]
                result += self.expressions(action=JN.Pexpr, scope=JT.BOOL, evaluation_type=JT.BOOL, r_depth=r_depth)
                result += self.instructions(action=JN.Pblock, r_depth=r_depth, scope=JS.Variables)

                return result

            if action == "ifelse":

                result = ["if "]
                result += self.expressions(action=JN.Pexpr, scope=JT.BOOL, evaluation_type=JT.BOOL)
                result += self.instructions(action=JN.Pblock, r_depth=r_depth, scope=JS.Variables)
                result += " else "
                result += self.instructions(action=JN.Pblock, r_depth=r_depth, scope=JS.Variables)

                return result

            if action == "forto" or action == "fordown":

                if JT.INT.name.lower() in self.variables_of_type:

                    if action == "forto":

                        """
                            
                            They all need to be the same type
                        
                        """
                        first_var = self.expressions(action=JN.Var, scope=JT.INT)
                        second_var = self.expressions(action=JN.Pexpr, scope=JT.INT, evaluation_type=JT.INT)
                        third_var = self.expressions(action=JN.Pexpr, scope=JT.INT, evaluation_type=JT.INT)

                        return ["for ", first_var, " = ", second_var, " to ", third_var,
                                self.instructions(action=JN.Pblock, r_depth=r_depth)]

                    if action == "fordown":

                        """
        
                            They all need to be the same type
        
                        """
                        first_var = self.expressions(action=JN.Var, scope=JT.INT, evaluation_type=JT.INT)
                        var_type = self.variable_types[first_var]
                        second_var = self.expressions(action=JN.Pexpr, scope=JT.INT, evaluation_type=JT.INT)
                        third_var = self.expressions(action=JN.Pexpr, scope=JT.INT, evaluation_type=JT.INT)

                        return ["for ", first_var, " = ", second_var, " downto ", third_var,
                               self.instructions(action=JN.Pblock, r_depth=r_depth, scope=JS.Variables)]
                else:

                    return self.instructions(action=JN.Pinstr, scope=scope)

            if action == "while":

                start_end = self.action_instructions.get_action(sub="while")
                result = ["while "]
                if start_end:
                    result += self.instructions(action=JN.Pblock, r_depth=r_depth, scope=JS.Variables)

                result += "("
                result += self.expressions(action=JN.Pexpr, evaluation_type=JT.BOOL, scope=JT.BOOL)
                result += ")"

                if not start_end:
                    result += self.instructions(action=JN.Pblock, r_depth=r_depth, scope=JS.Variables)

                return result

        if action == JN.Peqop:

            return self.action_instructions.get_action(sub=JN.Peqop)  #TODO make such that it return <var><peqop><var>

        if action == JN.Pblock:

            result = ["{\n"]
            result += self.instructions(action=JN.Pinstr, scope=JS.Variables, r_depth=r_depth)
            result += ["\n}"] #TODO should be able to do multiple

            return result

        if action == JN.Plvalue:

            action = self.action_instructions.get_action(sub=JN.Plvalue, r_depth=r_depth)

            if action == "_":

                return "_"

            if action == JN.Var:

                return self.expressions(action=JN.Var, r_depth=r_depth, scope=scope)

            if action == "array":

                return [self.expressions(action=JN.Var, r_depth=r_depth, scope=scope), "[",
                       self.expressions(action=JN.Pexpr, r_depth=r_depth, scope=scope), "]"]

        raise Exception("INSTRUCTION NO MATCH")

    """
    
        FUNCTIONS
    
    """

    def functions(self, action=None, r_depth=0):

        #print("Func: ", r_depth, "->", action)

        r_depth = r_depth + 1

        if action == JN.Pfunbody:

            result = ["{\n"]

            for _ in range(self.action_functions.get_amount_of_decls()):

                result += self.functions(action=JN.Pvardecl, r_depth=r_depth)

            for _ in range(self.action_functions.get_amount_of_instructions()):

                result += self.instructions(JN.Pinstr, r_depth=r_depth, scope=JS.Variables)
                result += "\n"

            if self.function_return:

                result += ["return ", self.functions(action="return", r_depth=r_depth), ";"]

                self.function_return = False

            result += ["\n}"]

            return result

        if action == JN.Storage:

            return self.action_functions.get_action(sub=JN.Storage, r_depth=r_depth)

        if action == JN.Stor_type:

            return self.functions(action=JN.Storage, r_depth=r_depth) + " " + self.types(action=JN.Ptype)

        if action == JN.Pvardecl:

            stor_type = self.functions(action=JN.Stor_type, r_depth=r_depth)
            variable = self.expressions(action=JN.Var, scope=JS.Decl, r_depth=r_depth)
            var_type = stor_type.split(" ")[1]

            """
            
                If var_type is of the form <type><brackets> it should be added to arrays as well
            
            """

            is_array = False
            if "[" in var_type:

                var_type = var_type.split("[")[0]
                is_array = True

            self.variable_types[variable] = var_type

            if is_array:

                self.variables[JS.Arrays].append(variable)

            if var_type in self.variables_of_type:

                self.variables_of_type[var_type].append(variable)

            else:

                self.variables_of_type[var_type] = [variable]

            return stor_type + " " + variable + ";\n"

        if action == "return":
            if self.return_types in self.variable_types:
                return self.get_variable(self.return_types) #TODO needs to be the same type as the declared return variable
            else:
                return "123"
        raise Exception("FUNCTION NO MATCH")

    """
    
        TYPES
    
    """

    def types(self, action=None, r_depth=0):

        r_depth = r_depth + 1

        if action == JN.Ptype:

            action = self.action_types.get_action(sub=JN.Ptype)

            if action == JT.BOOL:

                return "bool"

            if action == JT.INT:

                return "int"

            if action == JN.Utype:

                return self.types(action=JN.Utype).name.lower()

            if action == "array":

                return self.types(action=JN.Utype).name.lower() + "[5]" #TODO should be somekind of int declearing the size
                       #+ self.expressions(action=JN.Pexpr, r_depth=r_depth) + "]" #TODO should get int?!

        if action == JN.Utype:

            return self.action_types.get_action(sub=JN.Utype, r_depth=r_depth)

        raise Exception("TYPE NO MATCH")





